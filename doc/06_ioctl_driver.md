[<< back](04_devmem.md) | [index](01_index.md) | [forward >> ](04_uio_driver.md)

# IOCTL Driver

## Overview

If it comes to more complex driver operations and tight timing requirements, UIO drivers are quite limited because the logic runs in user space and cannot react on interrupts directly. Only within kernel drivers all the very performant features of the Linux kernel (e.g. queues) can be used to achieve maximal performance.

There are many different types of drivers you can choose from. However, the most common driver type is a character device with IOCTL operations. IOCTL operations allow passing an argument of any type. If a struct type is chosen, the number of input/output arguments is defined by the struct and hence practically unlimited.

As mentioned above, there are many different types of device drivers. We will implement a *misc device* because this is simpler than most other options. At the same time, it still gives us the freedom to act as character device with IOCTLs. A good article about the *misc device* can be found [here](https://www.linuxjournal.com/article/2920).

**The tutorial assumes you start on clean state generated by the Enclustra Build Environment, not on the state after the UIO Driver section**

## 1. Edit Device Tree

First we have to let Linux know about our device. To do so, we edit the devicetree.

Details about location of devicetree files, how to build them, etc. can be found in the  [Enclustra Build Environment - HowTo Guide](https://download.enclustra.com/public_files/Design_Support/Application%20Notes/Enclustra_Build_Environment_HowToGuide_V02.pdf)

In our case, we add the section below to the default devicetree:

<pre>
    fpga_base@43C10000{	
		status = "okay";
		compatible = "psi,fpga-base";
		reg = < 0x43C10000 0x1000 >;
		somevalue = < 0x9876 >;
	};
</pre>

The string assigned to *compatible* defines which driver to load. Each driver contains a list of such *compatible* strings it is compatible with. Linux will pair them (i.e. load a driver with matching string for each peripheral).

You may also wonder about the the line containing *somevalue*. This value does not have any meaning but is used to demonstrate how to pass information from the devicetree to the driver. In real-world this mechanism is used to pass information about the hardware to the driver.

The full device-tree file is available in [[root]/ioctl_driver/zx5-obru-uio.dts](../uio_driver/zx5-obru-ioctl.dts)

## 2. Compile Device Tree

The easiest way to compile the edited devicetree, is copying it to the folder *[root]/bsp-xilinx/sources/xilinx-linux/arch/arm/boot/dts* directory of your Enclustra Build Environment.

The device-tree can then be compiled into a devicetree-blob using the command below (from within the *dts* drectiory mentioned above):

<pre>
dtc -O dtb -o zx5-obru-ioctl.dtb zx5-obru-ioctl.dts
</pre>


The output file *zx5-obru-ioctl.dts* must be copied to the boot partition of the SD card and renamed to *devicetree.dtb* (as expected by the boot process) and hence replace de default *devicetree.dtb* file.

## 4. Write Kernel Module

A very small kernel module is required. It is only there to let the generic UIO driver know about the properties of the device (base address, interrupt number, etc.). 

The very basic code for this kernel module can be found in [[root]/uio_driver/fpga_base.c](../uio_driver/fpga_base.c). Note that the current version of the example code does not contain any interrupt support yet.

## 5. Compile Kernel Module



## Load Kernel Module

Bla, bla, bla

## 6. Write User Space Application

Bla bla bla

## Test User Space Application

Bla bla bla



[<< back](04_devmem.md) | [index](01_index.md) | [forward >> ](04_uio_driver.md)